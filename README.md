# Native VRF

Native VRF applies verifiable random function and simplifies process of participation. It combines on-chain data and random feed from public to generate a random number. In order to secure data feed, Native VRF requires data feeders to generate a valid signature with corresponding random input before publishing it to a blockchain. Each random number needs prior random result as a component. The prior random result is also an input of signatures generated by data feeders. With this data forming, Native VRF provides secure random number generation while keeping simplicity for participants.

This project aims to support random number generation on Ethereum compatible chains natively. Anyone can simply deploy and participate in decentralized random number generation. The system is more secure when there are more number of participants.

## Setup
1. Clone this repository
```shell
git clone https://github.com/dilukangelosl/native-vrf-whitelist
```
2. Copy the `.env.example` file and rename to `.env`
```shell
cp .env.example .env
```
3. Set the `PRIVATE_KEY` variable in the `.env` file using your wallet private key
4. Install required packages
```shell
npm i
```

## Deploy Native VRF
Run deploy script
```shell
npx hardhat run scripts/deploy/nativevrf.ts --network <target-network>
```
Example:
```shell
npx hardhat run scripts/deploy/nativevrf.ts --network kubchain_test
```

## Run fulfiller bot
Run fulfiller bot script
```shell
npx hardhat run scripts/examples/fulfill-bot.ts --network <target-network>
```
Example:
```shell
npx hardhat run scripts/examples/fulfill-bot.ts --network kubchain_test
```

## Example of Native VRF consumer
1. Deploy a consumer smart contract
```shell
npx hardhat run scripts/deploy/consumer.ts --network <target-network>
```
2. Run random request
```shell
npx hardhat run scripts/examples/request.ts --network <target-network>
```
3. Run random data record
```shell
npx hardhat run scripts/examples/record.ts --network <target-network>
```

## PrizeDrawConsumer Contract

The [`PrizeDrawConsumer.sol`](contracts/examples/PrizeDrawConsumer.sol) is a tutorial-style contract that demonstrates how to use Native VRF for weighted prize selection. This contract showcases:

### **Features**
- **Percentage-based Prize Selection**: Configure prizes with specific probability weights (e.g., 30%, 20%, 10%, 8%, 2%)
- **Gas-efficient Algorithm**: O(n) cumulative weight selection for optimal performance
- **Multi-user Support**: Handle simultaneous draw requests from multiple players
- **Flexible Configuration**: Create custom prize draws with different probability distributions
- **Owner Management**: Administrative controls for draw configuration and fund management

### **Example Prize Configuration**
```solidity
Prize 1: Grand Prize - Gold Coin (30% chance, 1 ETH value)
Prize 2: Second Prize - Silver Medal (20% chance, 0.5 ETH value)
Prize 3: Third Prize - Bronze Trophy (10% chance, 0.1 ETH value)
Prize 4: Fourth Prize - Lucky Charm (8% chance, 0.05 ETH value)
Prize 5: Fifth Prize - Participation Token (2% chance, 0.01 ETH value)
No Prize: 30% chance
```

### **Deploy PrizeDrawConsumer**
```shell
npx hardhat run scripts/deploy/prize-draw-consumer.ts --network <target-network>
```

### **Test PrizeDrawConsumer**
Run comprehensive tests including multi-user scenarios:
```shell
npx hardhat test test/PrizeDrawConsumer.test.ts
```

The test suite includes:
- **Multi-user testing**: 4 different player addresses testing simultaneous interactions
- **Prize selection validation**: Statistical verification over 1000+ simulations
- **Gas efficiency tests**: Ensures reasonable gas costs (<200k for requests, <50k for selection)
- **Edge case handling**: Tests minimum/maximum weights and invalid inputs
- **Integration testing**: Validates proper Native VRF integration

## Changelog

### Latest Improvements

#### feat: enhance VRF randomness generation with multi-stage entropy mixing

- Add address nonces to prevent replay attacks
- Implement global salt that updates per fulfillment
- Use multiple previous random results for better entropy
- Split random generation into 3 stages to avoid stack depth
- Include additional entropy sources (tx.origin, block.coinbase, gasleft)
- Enhance message hash with more unique identifiers
- Add owner functions for global salt management

This significantly improves randomness quality and prevents similar results

#### fix: replace deprecated block.difficulty with block.prevrandao

- Updated constructor random seed generation (line 73)
- Updated fullfillRandomnessInternal random generation (line 229)
- Fixes Solidity 0.8.30 compiler warnings about deprecated block.difficulty
- Maintains same entropy level for random number generation

#### NativeVRF.sol - Added Whitelist Access Control

**Owner System**: Contract deployer becomes owner with full administrative control

**Whitelist Mapping**: `mapping(address => bool) public whitelist` tracks approved addresses

**Access Restriction**: `requestRandom()` now requires `onlyWhitelisted` modifier

**Management Functions**:
- `whitelistAddress(address addr)` - Owner adds addresses to whitelist
- `delistAddress(address addr)` - Owner removes addresses from whitelist
- `isWhitelisted(address addr)` - Check whitelist status
- `transferOwnership(address newOwner)` - Transfer ownership

#### INativeVRF.sol - Updated Interface

- Added new function signatures for whitelist management
- Added events: `AddressWhitelisted`, `AddressDelisted`, `OwnershipTransferred`

## Full article
You can read full article that explains the building blocks and analysis of Native VRF and other RNGs. https://www.mdpi.com/2079-8954/11/7/326 

## Citation
Please cite our research article if you use this library in your research or projects.

Werapun W, Karode T, Suaboot J, Arporntip T, Sangiamkul E. NativeVRF: A Simplified Decentralized Random Number Generator on EVM Blockchains. Systems. 2023; 11(7):326. https://doi.org/10.3390/systems11070326